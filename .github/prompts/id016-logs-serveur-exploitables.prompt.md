# Prompt — id016 (P1) (M) Ajouter des logs serveur exploitables

## 1. Role

Tu es un ingénieur senior TypeScript spécialisé Bun 1.3.5 + Express (API), avec une forte sensibilité production (observabilité, exploitation, diagnostics) et qualité (tests Bun, changements minimaux, pas de sur-scope).

## 2. Objectif

Implémenter des **logs serveur exploitables** (stdout/stderr) pour diagnostiquer les incidents en production, en couvrant au minimum :

- le démarrage et l’arrêt du serveur,
- les erreurs de validation des requêtes (400),
- les opérations de lecture/écriture du fichier JSON de scores (y compris les échecs),
- les erreurs inattendues (500),

…sans changer le contrat d’erreurs JSON côté API et sans refactor massif.

Tâche ciblée : **id016** — « Ajouter des logs serveur exploitables ».

Rappel du TODO :

- **But :** Diagnostiquer en prod via stdout.
- **Livrable :** logs démarrage + validation + I/O JSON + erreurs.
- **Acceptation :** un incident d’écriture JSON est détectable via logs.
- **Dépendances :** id010, id012 (déjà implémentées).

## 3. Format de sortie

Produire une implémentation complète (code + tests + validations) dans le monorepo.

Attendus minimaux (tu peux ajuster si tu trouves mieux, mais reste simple) :

- Ajouter un module de logging côté serveur (ex : `project/server/src/logger.ts`) avec :
  - niveaux (`debug` / `info` / `warn` / `error`),
  - format stable et greppable (idéalement **JSON Lines**),
  - redaction minimale (ne pas logger le body des requêtes).
- Intégrer ce logger :
  - au démarrage/arrêt dans `project/server/src/index.ts`,
  - dans le middleware d’erreurs `project/server/src/app.ts` (validation / payload too large / internal),
  - dans la persistance JSON `project/server/src/storage/score-repository.ts` (read, write atomique, erreurs).
- Ajouter des tests Bun pertinents (au moins 1) qui prouvent que l’acceptation est satisfaite :
  - exemple attendu : provoquer un échec d’écriture/rename/suppression `.tmp` et vérifier qu’un log d’erreur exploitable est émis.
  - il est autorisé (et recommandé) d’injecter un logger “sink” en test pour capter les événements plutôt que de mocker `console` globalement.
- Exécuter les commandes de validation et ne cocher la tâche que si tout est vert.

Fichier à mettre à jour en fin de tâche (uniquement si succès) :

- `TODO.md` : cocher **uniquement** la case `id016`.

## 4. Contraintes

- Ne pas modifier les décisions structurantes : Bun **1.3.5**, TypeScript, Express, persistance fichier JSON mono-instance, jour Europe/Paris.
- Logs : **stdout/stderr** uniquement (compatible Docker/Compose).
- Ne pas exposer de stacktrace au client en production (déjà requis). Les logs internes peuvent contenir un message d’erreur utile, mais rester raisonnables.
- Ne pas surcharger : pas de gros framework d’observabilité. Préférer une solution simple et robuste.
- Éviter les dépendances additionnelles si une solution standard suffit. Si tu ajoutes une dépendance (ex: logger), justifie brièvement et garde l’intégration minimaliste.
- Respecter le contrat d’erreurs JSON existant (`AppError`, `toApiErrorBody`).
- Conserver le style existant : fichiers `kebab-case`, fonctions courtes, changements minimaux.

## 5. Contexte technique

Docs sources (sources de vérité pour cette tâche) :

- `docs/08-qualite-tests-et-ux.md` → section « Observabilité (MVP) » :
  - démarrage, lecture/écriture JSON, erreurs d’écriture, erreurs de validation.
- `docs/10-exploitation-et-maintenance.md` → section « Logs » :
  - source stdout/stderr du conteneur,
  - a minima : démarrage serveur, validation input, lecture/écriture JSON, erreurs inattendues.

Code existant (points d’ancrage) :

- `project/server/src/index.ts` : démarrage et shutdown, actuellement via `console.log`.
- `project/server/src/app.ts` : middleware d’erreur central, ne logge pas aujourd’hui.
- `project/server/src/storage/score-repository.ts` : persistance JSON + écriture atomique `.tmp` + rename, erreurs remontées.
- `project/server/src/routes/scores.ts` : validation (score/pseudo) via `AppError` 400.

## 6. Critères de validation

Checklist de succès (à respecter) :

- Logs présents et utiles :
  - démarrage (host/port) + arrêt (SIGINT/SIGTERM),
  - validation errors (400) loggées avec un contexte minimal (route/méthode/code),
  - lecture/écriture scores (chemins, opérations) + erreurs I/O loggées,
  - erreurs inattendues (500) loggées.
- L’acceptation est démontrée : un incident d’écriture JSON est **détectable via logs** (test automatisé ou preuve équivalente robuste).
- Tests OK : depuis `project/`, `bun test` passe.
- Typecheck OK : `bun run typecheck` passe (si script présent).
- Pas de régression sur le contrat d’erreur API.

## 7. Analyse des dépendances

- id010 (socle Express + `/api` + erreurs JSON) doit rester stable.
- id012 (repository scores + mutex + écriture atomique) ne doit pas être dégradée : tu ajoutes des logs, tu ne changes pas la sémantique.

## 8. Étapes proposées (à exécuter sans pause)

1. Définir une petite API de logger (type `Logger`) + une implémentation par défaut (stdout/stderr).
2. Ajouter un middleware optionnel de “request context” si utile (ex: request id), mais rester minimal.
3. Intégrer :
   - démarrage/shutdown,
   - middleware d’erreurs (log au bon niveau selon status/code),
   - repository (log des opérations et des erreurs I/O : read/parse/write/rename).
4. Ajouter des tests :
   - capturer les logs via injection d’un logger en mémoire,
   - forcer un échec d’écriture/rename (ex: permissions/chemin impossible) et vérifier qu’un `error` est émis avec un champ `event` clair et le `filePath`.
5. Lancer `bun test` puis `bun run typecheck`.

## 9. Cas limites à couvrir

- `scores.json` invalide (parse JSON) : log en `error` + message clair.
- Échec d’écriture atomique (write/rename/cleanup `.tmp`) : log en `error` incluant au minimum l’opération et le chemin.
- Payload trop gros (413) : log en `warn`.
- Production : ne pas modifier les réponses client ; le log doit suffire au diagnostic.

## 10. Clôture

- Exécuter (depuis `project/`) :
  - `bun test`
  - `bun run typecheck`
- Si (et seulement si) tous les critères de validation sont satisfaits :
  - cocher `- [ ]` → `- [x]` pour **id016** dans `TODO.md`.
- Ne pas cocher d’autres tâches.
